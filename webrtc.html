<!DOCTYPE html>

<html>
<head>  
  <link href="webrtc.css" rel="stylesheet" type="text/css">

  <title>WebRTC 1.0: Real-time Communication Between Browsers</title>
  <meta http-equiv='Content-Type' content='text/html; charset=utf-8'><!--
    === NOTA BENE ===
    For the three scripts below, if your spec resides on dev.w3 you can check them
    out in the same tree and use relative links so that they'll work offline.

    To tag a new releas in git hub

        Once the version is checked in and ready to go, you tag it with (need
        to chance the 20110823 to correct date )

             git tag -a v20110823 -m "This is release 20110823"

       Tags are not transferred by default with the push so you have to
       add a - -tags parameter to the push so it looks like. Note you need to
       remoce the space between the - and -tag to make a double dash. 

            git push - -tags 

       or alternatively you can push just the new tag with 

            git push origin v20110823


    To generate the dated version of the specification:

       Open this doc in Mozilla. 

       Do a CTRL-ALT-SHIFT-S

       Select "XHMTL( source)" from dialog box. This will pop a new tab with
       genreated version of the document.

       This will open a new tab with generated html. Copy and paste this to
       a new file. Note if you use Chrome or Safari, this step will not
       work. What will happen is the paste will have the original document,
       not what was displayed in the window that you did the copy on.

       Rename the new file to the correct day such as
       webrtc-broken-20111003.html then search for and edit the links for
       "This version" and "Previos version". Add the new file into CVS and
       check in. 

       Once everyone is happy, the webrtc-broken.html and
       webrtc-broken-20111003.html files can be coppied to
       webrtc.html and webrtc-20111003.html
       respectively in the ../editor/. directory. 
    -->
    <script class='remove'>
      var respecConfig = {
          specStatus: "ED",
          shortName:  "wicked-cool",
          edDraftURI: "http://dev.w3.org/respec2/docs/",
          editors: [
                {   name:       "Robin Berjon",
                    url:        "http://berjon.com/",
                    company:    "Vodafone",
                    companyURL: "http://vodafone.com/" },
                {   name:       "Gregg Kellogg",
                    company:    "Kellogg Associates",
                    companyURL: "http://kellogg-assoc.com/" },
          ],
          extraCSS:             ["../css/respec2.css"],
          noIDLIn:  true,

          wg:           "Device APIs and Policy Working Group",
          wgURI:        "http://www.w3.org/2009/dap/",
          wgPublicList: "public-device-apis",
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/43696/status",
      };
    </script>
    <!-- This is the real thing -->
    <!-- <script src='../js/profiles/w3c-common.js' class='remove'></script>
    <script data-main='w3c/profile-common' src='../js/require.js' class='remove'></script>-->
    <script src='respec2-74c9d7eb6d4b/js/profiles/w3c-common-loader.js' class='remove'></script>
<!--  <script src='respec2-74c9d7eb6d4b/js/w3c/style.js' class=
  'remove' type="text/javascript"></script>
  <script class='remove' type="text/javascript">
  var respecConfig = {
    // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
    specStatus:           "ED",

    // the specification's short name, as in http://www.w3.org/TR/short-name/
    shortName:            "webrtc",
    // if your specification has a subtitle that goes below the main
    // formal title, define it here
    // subtitle   :  "an excellent document",

    // if you wish the publication date to be other than today, set this
    publishDate: "",

    // new ability to override the copyright completely
    overrideCopyright: "<p class='copyright'>Initial Author of this Specification was Ian Hickson, Google Inc., with the following copyright statement:<br /> &#169; Copyright 2004-2011 Apple Computer, Inc., Mozilla Foundation, and Opera Software ASA. You are granted a license to use, reproduce and create derivative works of this document.</p> <p class='copyright'>All subsequent changes since 26 July 2011 done by the W3C WebRTC Working Group are under the following <a href='http://www.w3.org/Consortium/Legal/ipr-notice#Copyright'>Copyright</a>:<br />&#169; 2011-2012 <a href='http://www.w3.org/'><acronym title='World Wide Web Consortium'>W3C</acronym></a><sup>&#174;</sup>(<a href='http://www.csail.mit.edu/'><acronym title='Massachusetts Institute of Technology'>MIT</acronym></a>, <a href='http://www.ercim.eu/'><acronym title='European Research Consortium for Informatics and Mathematics'>ERCIM</acronym></a>, <a href='http://www.keio.ac.jp/'>Keio</a>), All Rights Reserved. <a href='http://www.w3.org/Consortium/Legal/copyright-documents'>Document use</a> rules apply.</p> <p class='copyright'>For the entire publication on the W3C site the <a href='http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer'>liability</a> and <a href='http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks'>trademark</a>rules apply.</p>",

    // if the specification's copyright date is a range of years, specify
    // the start date here:
    // copyrightStart: "2005",

    // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
    // and its maturity status
    previousPublishDate:  "2012-01-12",
    previousMaturity:  "ED",
    previousURI: "http://dev.w3.org/2011/webrtc/editor/webrtc-20120112.html",

    // if there a publicly available Editor's Draft, this is the link
    edDraftURI: "http://dev.w3.org/2011/webrtc/editor/webrtc.html",

    // if this is a LCWD, uncomment and set the end of its review period
    // lcEnd: "2009-08-05",

    // if you want to have extra CSS, append them to this list
    // it is RECOMMENDED that the respec.css stylesheet be kept
    extraCSS:             ["http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css"],
    //extraCSS:           ["../../../2009/dap/ReSpec.js/css/respec.css"],

    // editors, add as many as you like
    // only "name" is REQUIRED
    editors:  [
        // { name: "Your Name", url: "http://example.org/",
        //   company: "Your Company", companyURL: "http://example.com/" },
        { name: "Adam Bergkvist", company: "Ericsson" },
        { name: "Daniel C. Burnett", company: "Voxeo" },
        { name: "Cullen Jennings", company: "Cisco" },
        { name: "Anant Narayanan", company: "Mozilla" },
    ],

    // authors, add as many as you like. 
    // This is optional, uncomment if you have authors as well as editors.
    // only "name" is REQUIRED. Same format as editors.

    //authors:  [
    //    { name: "Your Name", url: "http://example.org/",
    //      company: "Your Company", companyURL: "http://example.com/" },
    //],
    
    // name of the WG
    wg:           "Web Real-Time Communications Working Group",
    
    // URI of the public WG page
    wgURI:        "http://www.w3.org/2011/04/webrtc/",

    // name (without the @w3c.org) of the public mailing to which comments are due
    wgPublicList: "public-webrtc",

    // URI of the patent status for this WG, for Rec-track documents
    // !!!! IMPORTANT !!!!
    // This is important for Rec-track documents, do not copy a patent URI from a random
    // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
    // Team Contact.
    wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/47318/status",
  };
  </script>-->
</head>

<body>
  <section id="abstract">
    <p>This document defines a set of APIs to represent streaming media,
    including audio and video, in JavaScript, to allow media to be sent over
    the network to another browser or device implementing the appropriate set
    of real-time protocols, and media received from another browser or device
    to be processed and displayed locally. This specification is being
    developed in conjunction with a protocol specification developed by the
    IETF RTCWEB group and an API specification to get access to local media
    devices developed by the Media Capture Task Force.</p>
  </section>

  <section id="conformance">
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification must implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]], as
    this specification uses that specification and terminology.</p>
  </section>

  <section id="sotd">
    <p>This document is not complete. It is subject to major changes and, while
    early experimentations are encouraged, it is therefore not intended for
    implementation. The API is based on preliminary work done in the WHATWG.
    The Web Real-Time Communications Working Group expects this specification
    to evolve significantly based on:</p>

    <ul>
      <li>The outcomes of ongoing exchanges in the companion RTCWEB group at
      IETF to define the set of protocols that, together with this document,
      will enable real-time communications in Web browsers.</li>

      <li>Privacy issues that arise when exposing local capabilities and local
      streams.</li>

      <li>Technical discussions within the group, on the data channel in
      particular.</li>

      <li>Experience gained through early experimentations.</li>

      <li>Feedback received from other groups and individuals.</li>
    </ul>

    <p>As the specification matures, the group hopes to strike the right
    balance between a low-level API that would enable interested parties to
    tweak potentially complex system parameters, and a more high-level API that
    Web developers can use without <em>a priori</em> technical knowledge about
    real-time communications.</p>
  </section>

  <section id="intro" class="informative">
    <h2>Introduction</h2>

    <p>There are a number of facets to video-conferencing in HTML covered by
    this specification:</p>

    <ul>
      <li>Representing a multimedia stream (video, audio, or both) from local
      devices (video cameras, microphones, Web cams) or from prerecorded files
      provided by the user.</li>

      <li>Recording such streams locally.</li>

      <li>Connecting to remote peers using NAT-traversal technologies such as
      ICE, STUN, and TURN.</li>

      <li>Sending the locally-produced streams to remote peers and receiving
      streams from remote peers.</li>

      <li>Displaying such streams (both the locally-produced ones and the
      remotely-obtained ones) locally using the <code>video</code> or
      <code>audio</code> elements.</li>

      <li>Sending arbitrary data to remote peers.</li>
    </ul>

    <p>This document defines the APIs used for these features. This
    specification is being developed in conjunction with a protocol
    specification developed by the <a href=
    "http://datatracker.ietf.org/wg/rtcweb/">IETF RTCWEB group</a> and an API
    specification to get access to local media devices developed by the
    <a href="http://www.w3.org/2011/04/webrtc/">Media Capture Task
    Force</a>.</p>
  </section>

  <section>
    <h2>Network Stream API</h2>

    <section>
      <h3>Introduction</h3>

      <p>The <code>MediaStream</code> interface, as defined in the
      [[!GETUSERMEDIA]] specification, typically represents a stream of data of
      audio and/or video. This object may be extended to also represent a stream
      that either comes from or is sent to a remote node (and not just the local
      camera, for instance). The extensions required to enable this capability
      on the <code>MediaStream</code> object will be described in this
      document.</p>

      <p>A <code>MediaStream</code> as defined in [[!GETUSERMEDIA]] may contain
      zero or more <code>MediaStreamTrack</code> objects. A
      <code>MediaStreamTrack</code> sent to another peer MUST appear as one and
      only one <code>MediaStreamTrack</code> to the recipient.</p>

      <p>Channels are the smallest unit considered in the <code>MediaStream</code>
      specification. Channels are intended to be
      encoded together for transmission as, for instance, an RTP payload type.
      All of the channels that a codec needs to encode jointly MUST be in the
      same <code>MediaStreamTrack</code> and the codecs SHOULD be able to
      encode, or discard, all the channels in the track.</p>

      <p>The concepts of an input and output to a given
      <code>MediaStream</code> apply in the case of <code>MediaStream</code> objects
      transmitted over the network as well. A <code><a>MediaStream</a></code>
      created by a <code><a>PeerConnection</a></code> object (later described in
      this document) will take as input the data received from a remote peer.
      Similarly, a <code>MediaStream</code> from a local source, for instance a
      camera via [[!GETUSERMEDIA]] will have an output that represents what is
      transmitted to a remote peer if the object is used with a
      <code><a>PeerConnection</a></code> object.</p>

      <p>The concept of duplicating <code>MediaStream</code> objects as described in
      [[!GETUSERMEDIA]] is also applicable here. This feature can be used, for
      instance, in a video-conferencing scenario to display the local video
      from the user’s camera and microphone in a local monitor, while only
      transmitting the audio to the remote peer (e.g. in response to the user
      using a "video mute" feature). Combining tracks from different
      <code><a>MediaStream</a></code> objects into a new
      <code><a>MediaStream</a></code> is useful in certain cases.</p>
    </section>

    <section>
      <h3>Interface definitions</h3>

      <p class='note'>In this section, we only specify aspects of the the
      following objects that are relevant when used along with a
      <code>PeerConnection</code>. Please refer to the original definitions of
      the objects in the [[!GETUSERMEDIA]] document for general information on
      using <code>MediaStream</code> and <code>MediaStreamTrack</code> both
      in and outside the context of <code>PeerConnection</code>.</p>

      <section>
        <h4>MediaStream</h4>

        <section>
          <h4>label</h4>

          <p>The <code>label</code> attribute specified in
          <code>MediaStream</code> returns a label that is unique to this
          stream, so that streams can be recognized after they are sent through
          the <code><a href="#peerconnection">PeerConnection</a></code>
          API.</p>

          <p>When a <code><a href="#mediastream">MediaStream</a></code> is
          created to represent a stream obtained from a remote peer, the
          <code>label</code> attribute is initialized
          from information provided by the remote source.</p>

          <p class='note'>The label of a <code><a>MediaStream</a></code> object
          is unique to the source of the stream, but that does not mean it is
          not possible to end up with duplicates. For example, a locally
          generated stream could be sent from one user to a remote peer using
          <code><a>PeerConnection</a></code>, and then sent back to the
          original user in the same manner, in which case the original user
          will have multiple streams with the same label (the locally-generated
          one and the one received from the remote peer).</p>
        </section>

        <section>
          <h4>Events on MediaStream</h4>

          <p>A new media component may be associated with an existing
          <code><a>MediaStream</a></code>. This happens, e.g., on the A-side
          when the B-side adds a new <code><a>MediaStreamTrack</a></code>
          object to one of the track lists of a <code><a>MediaStream</a></code>
          that is being sent over a <code><a>PeerConnection</a></code>. If this
          happens for the reason exemplified, or for any other reason than the
          <code>add()</code> [[!GETUSERMEDIA]] method
          being invoked locally on a <code><a>MediaStreamTrackList</a></code>
          or tracks are being added as the stream is created (i.e. the stream
          is initialized with tracks), the user agent MUST run the following
          steps:</p>

          <ol>
            <li>
              <p>Create a <code><a>MediaStreamTrack</a></code> object
              <var>track</var> to represent the new media component.</p>
            </li>

            <li>
              <p>If <var>track’s</var> <code><a href=
              "#dom-mediastreamtrack-kind">kind</a></code> attribute equals
              "<code>audio</code>", add it to the
              <code><a>MediaStream</a></code> object’s <code><a href=
              "#dom-mediastream-audiotracks">audioTracks</a></code>
              <code><a>MediaStreamTrackList</a></code> object.</p>
            </li>

            <li>
              <p>If <var>track’s</var> <code><a href=
              "#dom-mediastreamtrack-kind">kind</a></code> attribute equals
              "<code>video</code>", add it to the
              <code><a>MediaStream</a></code> object’s <code><a href=
              "#dom-mediastream-videotracks">videoTracks</a></code>
              <code><a>MediaStreamTrackList</a></code> object.</p>
            </li>

            <li>
              <p><a>Fire a track event</a> named <code><a href=
              "#event-mediastreamtracklist-addtrack">addtrack</a></code> with
              the newly created <var>track</var> at the
              <code><a>MediaStreamTrackList</a></code> object.</p>
            </li>
          </ol>

          <p>An existing media component may also be disassociated from a
          <code><a>MediaStream</a></code>. If this happens for any other reason
          than the <code>remove()</code> [[!GETUSERMEDIA]] method being
          invoked locally on a <code><a>MediaStreamTrackList</a></code> or the
          stream is being destroyed, the user agent MUST run the following
          steps:</p>

          <ol>
            <li>
              <p>Let <var>track</var> be the
              <code><a>MediaStreamTrack</a></code> object representing the
              media component about to be removed.</p>
            </li>

            <li>
              <p>Remove <var>track</var> from the
              <code><a>MediaStreamTrackList</a></code> object.</p>
            </li>

            <li>
              <p><a>Fire a track event</a> named <code><a href=
              "#event-mediastreamtracklist-removetrack">removetrack</a></code>
              with <var>track</var> at the
              <code><a>MediaStreamTrackList</a></code> object.</p>
            </li>
          </ol>

          <p>The event source for the <code>onended</code> event in the
          networked case is the <code>PeerConnection</code> object.</p>
        </section>
      </section>

      <section>
        <h4>MediaStreamTrack</h4>

        <p>A <code>MediaStreamTrack</code> object’s reference to its
        <code>MediaStream</code> in the non-local media source case (an RTP
        source, as is the case for a <code>MediaStream</code> received over a
        <code>PeerConnection</code>) is always strong.</p>

        <p>When a track belongs to a <code><a>MediaStream</a></code> that comes
        from a remote peer and the remote peer has permanently stopped sending
        data the <code>ended</code> event MUST be fired on the track, as
        specified in [[!GETUSERMEDIA]].</p>

        <p>A track in a <code><a>MediaStream</a></code>, received with a
        <code><a>PeerConnection</a></code>, MUST have its
        <code>readyState</code> attribute [[!GETUSERMEDIA]] set
        to <code><a href="#widl-MediaStreamTrack-MUTED">MUTED</a></code> (1)
        until media data arrives.</p>

        <p>In addition, a <code>MediaStreamTrack</code> has its <code>readyState</code> set
        to <code>MUTED</code> on the B-side if the A-side disables the
        corresponding <code><a>MediaStreamTrack</a></code> in the
        <code><a>MediaStream</a></code> that is being sent. When the addstream
        event triggers on a <code><a>PeerConnection</a></code>, all
        <code><a>MediaStreamTrack</a></code> objects in the resulting
        <code><a>MediaStream</a></code> are muted until media data can be read
        from the RTP source.</p>
      </section>
    </section>

    <section>
      <h4>AudioMediaStreamTrack</h4>

      <p>The <code><a>AudioMediaStreamTrack</a></code> is a specialization of
      of a normal <code><a>MediaStreamTrack</a></code> that only carries audio
      and is extended to have the capability to send and/or receive DTMF
      codes.</p>

      <dl title='interface AudioMediaStreamTrack : MediaStreamTrack' class=
      'idl'>
        <dt>readonly attribute boolean canInsertDTMF</dt>

        <dd>
          <p>The <dfn id=
          'dom-audiomediastreamtrack-caninsertdtmf'><code>canInsertDTMF</code></dfn>
          attribute MUST indicate if the
          <code><a>AudioMediaStreamTrack</a></code> is capable of sending
          DTMF.</p>
        </dd>

        <dt>void insertDTMF(in DOMString tones, optional long duration)</dt>

        <dd>
          <p>When a <code><a>AudioMediaStreamTrack</a></code> object’s <dfn id=
          'dom-AudioMediaStreamTrack-insertDTMF'><code>insertDTMF()</code></dfn>
          method is invoked, the user agent MUST queue a task that that sends
          the DTMF tones.</p>

          <p>The tone parameters is treated as a series of characters. The
          characters 0 to 9, A to D, #, and * generated the associated DTMF
          tones. The characters a to d are equivalent to A to D. The character
          , indicates a an delay of 2 seconds before processing the next
          character in the tones parameter. Unrecognized characters are
          ignored.</p>

          <p>The duration parameters indicates the duration in ms to play the
          each DTMF passed in the tones parameters. The duration can not be
          more than 6000 or less than 70. The default duration is 100 ms for
          each tone. The gap between tones MUST be at least 50 ms but should be
          as short as possible.</p>

          <p>If insertDTMF is called on the same object while an existing task
          for this object is generate DTMF is still running, the previous task
          is canceled. Calling insertDTMF with an empty tones parameter can be
          used to cancel any tones currently being send.</p>

          <p class='note'>Editor Note: We need to add a callback that is set on
          the object that is called after the tones are sent. This is needed to
          allow the application to know when it can send new tones without
          canceling the tones that are currently being sent.</p>

          <p class='note'>Editor Note: It seems we would want a callback or
          event for incoming tones. The proposal sent to the list had them
          played as audio to the speaker but I don’t see how that is
          useful.</p>
        </dd>
      </dl>
    </section>
  </section>

  <section>
    <h2>Peer-to-peer connections</h2>

    <p>A <code><a>PeerConnection</a></code> allows two users to communicate
    directly, browser-to-browser. Communications are coordinated via a
    signaling channel provided by script in the page via the server, e.g. using
    <code>XMLHttpRequest</code>.</p>

    <p>Calling <code>new <a>PeerConnection</a>(<var>configuration</var>,
    <var>signalingCallback</var>)</code> creates a
    <code><a>PeerConnection</a></code> object.</p>

    <p>The <var>configuration</var> string gives the address of a STUN or TURN
    server to use to establish the connection. [[!STUN]] [[!TURN]]</p>

    <p>The allowed formats for this string are:</p>

    <dl>
      <dt>"<code><var>TYPE</var> 203.0.113.2:3478</code>"</dt>

      <dd>
        <p>Indicates a specific IP address and port for the server.</p>
      </dd>

      <dt>"<code><var>TYPE</var> relay.example.net:3478</code>"</dt>

      <dd>
        <p>Indicates a specific host and port for the server; the user agent
        will look up the IP address in DNS.</p>
      </dd>

      <dt>"<code><var>TYPE</var> example.net</code>"</dt>

      <dd>
        <p>Indicates a specific domain for the server; the user agent will look
        up the IP address and port in DNS.</p>
      </dd>
    </dl>

    <p>The "<code><var>TYPE</var></code>" is one of:</p>

    <dl>
      <dt><code>STUN</code></dt>

      <dd>Indicates a STUN server</dd>

      <dt><code>STUNS</code></dt>

      <dd>Indicates a STUN server that is to be contacted using a TLS
      session.</dd>

      <dt><code>TURN</code></dt>

      <dd>Indicates a TURN server</dd>

      <dt><code>TURNS</code></dt>

      <dd>Indicates a TURN server that is to be contacted using a TLS
      session.</dd>
    </dl>

    <p>The <var>signalingCallback</var> argument is a method that will be
    invoked when the user agent needs to send a message to the other host over
    the signaling channel. When the callback is invoked, convey its first
    argument (a string) to the other peer using whatever method is being used
    by the Web application to relay signaling messages. (Messages returned from
    the other peer are provided back to the user agent using the <code><a href=
    "#dom-peerconnection-processsignalingmessage">processSignalingMessage()</a></code>
    method.)</p>

    <p>A <code><a>PeerConnection</a></code> object has an associated <dfn id=
    'peerconnection-signaling-callback'><code>PeerConnection</code> signaling
    callback</dfn>, a <dfn id=
    'peerconnection-ice-agent'><code>PeerConnection</code> ICE Agent</dfn>, 
    <!--a <dfn id=
  'peerconnection-data-udp-media-stream'><code>PeerConnection</code> data UDP media
  stream</dfn>, -->
     a <dfn id='peerconnection-readiness-state'><code>PeerConnection</code>
    readiness state</dfn> and an <dfn id='ice-started-flag'>SDP Agent</dfn>.
    These are initialized when the object is created.</p>

    <p>When the <dfn id=
    'dom-peerconnection'><code>PeerConnection()</code></dfn> constructor is
    invoked, the user agent MUST run the following steps. This algorithm has a
    synchronous section (which is triggered as part of the event loop
    algorithm). Steps in the synchronous section are marked with ⌛.</p>

    <ol>
      <li>
        <p>Let <var>serverConfiguration</var> be the constructor’s first
        argument.</p>
      </li>

      <li>
        <p>Let <var>signalingCallback</var> be the constructor’s second
        argument.</p>
      </li>

      <li>
        <p>Let <var>connection</var> be a newly created
        <code><a>PeerConnection</a></code> object.</p>
      </li>

      <li>
        <p>Create an ICE Agent and let <var>connection</var>’s <a href=
        "#peerconnection-ice-agent"><code>PeerConnection</code> ICE Agent</a>
        be that ICE Agent. [[!ICE]]</p>
      </li>

      <li>
        <p>If <var>serverConfiguration</var> contains a U+000A LINE FEED (LF)
        character or a U+000D CARRIAGE RETURN (CR) character (or both), remove
        all characters from <var>serverConfiguration</var> after the first such
        character.</p>
      </li>

      <li>
        <p><span title="split a string on spaces">Split <var title=
        "">serverConfiguration</var> on spaces</span> to obtain
        <var>configuration components</var>.</p>
      </li>

      <li>
        <p>If <var>configuration components</var> has two or more components,
        and the first component is a case-sensitive match for one of the
        following strings:</p>

        <ul class='breif'>
          <li>"<code>STUN</code>"</li>

          <li>"<code>STUNS</code>"</li>

          <li>"<code>TURN</code>"</li>

          <li>"<code>TURNS</code>"</li>
        </ul>

        <p>...then run the following substeps:</p>

        <ol>
          <li>
            <p>Let <var>server type</var> be STUN if the first component of
            <var>configuration components</var> is '<code>STUN</code>' or
            '<code>STUNS</code>', and TURN otherwise (the first component of
            <var>configuration components</var> is "<code>TURN</code>" or
            "<code>TURNS</code>").</p>
          </li>

          <li>
            <p>Let <var>secure</var> be true if the first component of
            <var title="">configuration components</var> is
            "<code>STUNS</code>" or "<code>TURNS</code>", and false
            otherwise.</p>
          </li>

          <li>
            <p>Let <var>host</var> be the contents of the second component of
            <var>configuration components</var> up to the character before the
            first U+003A COLON character (:), if any, or the entire string
            otherwise.</p>
          </li>

          <li>
            <p>Let <var>port</var> be the contents of the second component of
            <var>configuration components</var> from the character after the
            first U+003A COLON character (:) up to the end, if any, or the
            empty string otherwise.</p>
          </li>

          <li>
            <p>Configure the <a href=
            "#peerconnection-ice-agent"><code>PeerConnection</code> ICE
            Agent</a>’s STUN or TURN server as follows:</p>

            <ul>
              <li>If <var>server type</var> is STUN, the server is a STUN
              server. Otherwise, <var>server type</var> is TURN and the server
              is a TURN server.</li>

              <li>If <var>secure</var> is true, the server is to be contacted
              using TLS-over-TCP, otherwise, it is to be contacted using
              UDP.</li>

              <li>The IP address, host name, or domain name of the server is
              <var title="">host</var>.</li>

              <li>The port to use is <var>port</var>. If this is the empty
              string, then only a domain name is configured (and the ICE Agent
              will use DNS SRV requests to determine the IP address and
              port).</li>

              <li>The long-term username for the STUN or TURN server is the
              <span title="ASCII serialization of an origin">ASCII
              serialization</span> of the entry script’s origin; the long-term
              password is the empty string.</li>
            </ul>

            <p>If the given IP address, host name, domain name, or port are
            invalid, then the user agent MUST act as if no STUN or TURN server
            is configured.</p>
          </li>
        </ol>
      </li>

      <li>
        <p>Let the <var>connection</var>’s <a href=
        "#peerconnection-signaling-callback"><code>PeerConnection</code>
        signaling callback</a> be <var>signalingCallback</var>.</p>
      </li>

      <li>
        <p>Set <var>connection</var>’s <a href=
        "#peerconnection-readiness-state"><code>PeerConnection</code> readiness
        state</a> to <code><a href="#widl-PeerConnection-NEW">NEW</a></code>
        (0).</p>
      </li>

      <li>
        <p>Set <var>connection</var>’s <a href=
        "#peerconnection-readiness-state"><code>PeerConnection</code> ice
        state</a> to <code><a href="#widl-PeerConnection-NEW">NEW</a></code>
        (0).</p>
      </li>

      <li>
        <p>Set <var>connection</var>’s <a href=
        "#peerconnection-readiness-state"><code>PeerConnection</code> sdp
        state</a> to <code><a href="#widl-PeerConnection-NEW">NEW</a></code>
        (0).</p>
      </li><!--
    <li>
      <p>Let <var>connection</var>’s <a href=
      "#peerconnection-data-udp-media-stream"><code>PeerConnection</code> data UDP media
      stream</a> be a new <a href="#data-udp-media-stream">data UDP media stream</a>.</p>
    </li>
-->

      <li>
        <p>Let <var>connection</var>’s <code title=
        'dom-PeerConnection-localStreams'><a href=
        "#widl-PeerConnection-localStreams">localStreams</a></code> attribute
        be an empty read-only <code><a>MediaStream</a></code> array.</p>
      </li>

      <li>
        <p>Let <var>connection</var>’s <code title=
        'dom-PeerConnection-remoteStreams'><a href=
        "#widl-PeerConnection-remoteStreams">remoteStreams</a></code> attribute
        be an empty read-only <code><a>MediaStream</a></code> array.</p>
      </li>

      <li>
        <p>Return <var>connection</var>, but continue these steps
        asynchronously.</p>
      </li>

      <li>
        <p>Await a stable state. The synchronous section consists of the
        remaining steps of this algorithm. (Steps in <span title=
        "synchronous section">synchronous sections</span> are marked with
        ⌛.)</p>
      </li>

      <li>
        <p>⌛ If the ice state is set to NEW, it MUST queue a task to start
        gathering ICE address and set the ice state to ICE_GATHERING.</p>
      </li>

      <li>
        <p>⌛ Once the ICE address gathering is complete, if there are any
        streams in localStreams, the SDP Agent will send the initial the SDP
        offer. The initial SDP offer MUST contain both the ICE candidate
        information as well as the SDP to represent the media descriptions for
        all the streams in localStreams.</p>
      </li>
    </ol>

    <p>During the lifetime of the peerConnection object, the following
    procedures are followed:</p>

    <ol>
      <li>
        <p>If a local media stream has been added and an SDP offer needs to be
        sent, and the ICE state is not NEW or ICE_GATHERING, and the SDP Agent
        state is NEW or SDP_IDLE, then send and queue a task to send an SDP
        offer and change the SPD state to SDP Waiting.</p>
      </li>

      <li>
        <p>If an SDP offer has been received, and the SDP state is NEW or
        SDP_IDLE, pass the ICE candidates from the SDP offer to the ICE Agent
        and change it state to ICE_CHECKING. Construct an appropriate SDP
        answer, update the remote streams, queue a task to send the SDP offer,
        and set the SDPAgent state to SDP_IDLE.</p>
      </li>

      <li>
        <p>At the point the sdpState changes from NEW to some other state, the
        readyState changes to NEGOTIATING.</p>
      </li>

      <li>
        <p>If the ICE Agent finds a candidates that froms a valid connection,
        the ICE state is changed to ICE_CONNECTED</p>
      </li>

      <li>
        <p>If the ICE Agent finishes checking all candidates, if a connection
        has been found, the ice state is changed to ICE_COMPLETED and if not
        connection has been found it is changed to ICE_FAILED.</p>
      </li>

      <li>
        <p>If the iceState is ICE_CONNECTED or ICE_COMPLETED and the SDP stat
        is SDP_IDLE, the readyState is set to ACTIVE.</p>
      </li>

      <li>
        <p>If the iceState is ICE_FAILED, a task is queued to calls the close
        method.</p>
      </li>

      <li>
        <p>The close method will cause the system to wait until the sdpStat is
        SDP_IDLE then it will send an SDP offer terminating all media and
        change the readyState to CLOSING as well as stop all ICE process and
        change the iceState to ICE_CLOSED. Once an SDP anser to this offer is
        received, the readyState will be changed to CLOSED.</p>
      </li>
    </ol>

    <p>User agents MAY negotiate any codec and any resolution, bitrate, or
    other quality metric. User agents are encouraged to initially negotiate for
    the native resolution of the stream. For streams that are then rendered
    (using a <code>video</code> element), user agents are encouraged to
    renegotiate for a resolution that matches the rendered display size.</p>

    <p class="note">Starting with the native resolution means that if the Web
    application notifies its peer of the native resolution as it starts sending
    data, and the peer prepares its <code>video</code> element accordingly,
    there will be no need for a renegotiation once the stream is flowing.</p>

    <p>All SDP media descriptions for streams represented by
    <code><a>MediaStream</a></code> objects MUST include a label attribute
    ("<code title="">a=label:</code>") whose value is the value of the
    <code><a>MediaStream</a></code> object’s <code title=
    'dom-MediaStream-label'><a href="#dom-mediastream-label">label</a></code>
    attribute. [[!SDP]] [[!SDPLABEL]]</p>

    <p><a href="#peerconnection"><code>PeerConnection</code>s</a> MUST not
    generate any candidates for media streams whose media descriptions do not
    have a label attribute ("<code>a=label:</code>"). [[!ICE]] [[!SDP]]
    [[!SDPLABEL]]</p>

    <p>When a user agent has reached the point in the media negotiation where a
    <code><a>MediaStream</a></code> can be created to represent incoming
    components, the user agent MUST run the following steps:</p>

    <ol>
      <li>
        <p>Let <var>connection</var> be the <code><a>PeerConnection</a></code>
        expecting this media.</p>
      </li>

      <li>
        <p>Create a <code><a>MediaStream</a></code> object to represent the
        media stream. Set its <code><a href=
        "#dom-mediastream-label">label</a></code> attribute to the value of the
        SDP Label attribute for that component’s media stream.</p>
      </li>

      <li>
        <p>Run the following steps for each component in the media stream.</p>

        <ol>
          <li>
            <p>Create a <code><a>MediaStreamTrack</a></code> object
            <var>track</var> to represent the component.</p>
          </li>

          <li>
            <p>If <var>track’s</var> <code><a href=
            "#dom-mediastreamtrack-kind">kind</a></code> attribute equals
            "<code>audio</code>", add it to the <code><a>MediaStream</a></code>
            object’s <code><a href=
            "#dom-mediastream-audiotracks">audioTracks</a></code>
            <code><a>MediaStreamTrackList</a></code> object.</p>
          </li>

          <li>
            <p>If <var>track’s</var> <code><a href=
            "#dom-mediastreamtrack-kind">kind</a></code> attribute equals
            "<code>video</code>", add it to the <code><a>MediaStream</a></code>
            object’s <code><a href=
            "#dom-mediastream-videotracks">videoTracks</a></code>
            <code><a>MediaStreamTrackList</a></code> object.</p>
          </li>
        </ol>

        <p class='note'>The internal order in the
        <code><a>MediaStreamTrackList</a></code> objects on the receiving side
        should reflect the order on the sending side. One way to enforce this
        is to specify the order in the SDP.</p>
      </li>

      <li>
        <p>Queue a task to run the following substeps:</p>

        <ol>
          <li>
            <p>If the <var>connection</var>’s <a href=
            "#peerconnection-readiness-state"><code>PeerConnection</code>
            readiness state</a> is <code><a href=
            "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), abort these
            steps.</p>
          </li><!-- close() was probably called just before this
     task ran -->

          <li>
            <p>Add the newly created <code><a>MediaStream</a></code> object to
            the end of <var>connection</var>’s <code title=
            'dom-PeerConnection-remoteStreams'><a href=
            "#widl-PeerConnection-remoteStreams">remoteStreams</a></code>
            array.</p>
          </li>

          <li>
            <p><a href="#fire-a-stream-event">Fire a stream event</a> named
            <code title='event-MediaStream-addstream'><a href=
            "#event-mediastream-addstream">addstream</a></code> with the newly
            created <code><a>MediaStream</a></code> object at the <var title=
            "">connection</var> object.</p>
          </li>
        </ol>
      </li>
    </ol>

    <p>When a user agent has negotiated media for a component that belongs to a
    media stream thas is already represented by an existing
    <code><a>MediaStream</a></code> object, the user agent MUST associate the
    component with that <code><a>MediaStream</a></code> object.</p>

    <p>When a <a href="#peerconnection"><code>PeerConnection</code></a> finds
    that a stream from the remote peer has been removed (its port has been set
    to zero in a media description sent on the signaling channel), the user
    agent MUST follow these steps:</p>

    <ol>
      <li>
        <p>Let <var>connection</var> be the <code><a>PeerConnection</a></code>
        associated with the stream being removed.</p>
      </li>

      <li>
        <p>Let <var>stream</var> be the <code><a>MediaStream</a></code> object
        that represents the media stream being removed, if any. If there isn’t
        one, then abort these steps.</p>
      </li>

      <li>
        <p>By definition, <var>stream</var> is now <a>finished</a>.</p>

        <p class='note'>A <span title='concept-task'>task</span> is thus
        <span title="queue a task">queued</span> to update <var>stream</var>
        and fire an event.</p>
      </li>

      <li>
        <p>Queue a task to run the following substeps:</p>

        <ol>
          <li>
            <p>If the <var>connection</var>’s <a href=
            "#peerconnection-readiness-state"><code>PeerConnection</code>
            readiness state</a> is <code><a href=
            "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), abort these
            steps.</p>
          </li><!-- close() was probably called just before this
     task ran -->

          <li>
            <p>Remove <var>stream</var> from <var>connection</var>’s
            <code><a href=
            "#widl-PeerConnection-remoteStreams">remoteStreams</a></code>
            array.</p>
          </li>

          <li>
            <p><a href="#fire-a-stream-event">Fire a stream event</a> named
            <code title='event-MediaStream-removestream'><a href=
            "#event-mediastream-removestream">removestream</a></code> with
            <var title="">stream</var> at the <var>connection</var> object.</p>
          </li>
        </ol>
      </li>
    </ol>

    <p>The task source for the <span title='concept-task'>tasks</span> listed
    in this section is the networking task source.</p>

    <p>If a <code><a>PeerConnection</a></code> object is <a title=
    "consumer">consuming</a> a <code><a>MediaStream</a></code> and a track is
    added to one of the stream’s <code><a>MediaStreaMtrackList</a></code>
    objects, by, e.g., the <code><a href=
    "#dom-mediastreamtracklist-add">add()</a></code> method being invoked, the
    <code><a>PeerConnection</a></code> object MUST add a media component for
    that track the next time the user agent <span title=
    "provide a stable state">provides a stable state</span>. The user agent
    MUST also remove a media component in same way.</p>

    <p class="warning">To prevent network sniffing from allowing a fourth party
    to establish a connection to a peer using the information sent out-of-band
    to the other peer and thus spoofing the client, the configuration
    information SHOULD always be transmitted using an encrypted connection.</p>

    <section>
      <h3>PeerConnection</h3>

      <dl title=
      '[Constructor (DOMString configuration, SignalingCallback signalingCallback)] interface PeerConnection'
      class='idl'>
        <dt>void processSignalingMessage (DOMString message)</dt>

        <dd>
          <p>When a message is relayed from the remote peer over the signaling
          channel is received by the Web application, pass it to the user agent
          by calling the <code><a href=
          "#dom-peerconnection-processsignalingmessage">processSignalingMessage()</a></code>
          method.</p>

          <p>The order of messages is important. Passing messages to the user
          agent in a different order than they were generated by the remote
          peer’s user agent can prevent a successful connection from being
          established or degrade the connection’s quality if one is
          established.</p>

          <p>When the <dfn id=
          'dom-peerconnection-processsignalingmessage'><code title=
          '""'>processSignalingMessage()</code></dfn> method is invoked, the
          user agent MUST run the following steps:</p>

          <ol>
            <li>
              <p>Let <var>message</var> be the method’s argument.</p>
            </li>

            <li>
              <p>Let <var>connection</var> be the
              <code><a>PeerConnection</a></code> object on which the method was
              invoked.</p>
            </li>

            <li>
              <p>If <var>connection</var>’s <a href=
              "#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> is <code><a href=
              "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), throw an
              <code>INVALID_STATE_ERR</code> exception.</p>
            </li>

            <li>
              <p>If the first four characters of <var>message</var> are not
              "<code>SDP</code>" followed by a U+000A LINE FEED (LF) character,
              then abort these steps. (This indicates an error in the signaling
              channel implementation. User agents MAY report such errors to
              their developer consoles to aid debugging.)</p>

              <p class='note'>Future extensions to the
              <code><a>PeerConnection</a></code> interface might use other
              prefix values to implement additional features.</p>
            </li>

            <li>
              <p>Let <var>sdp</var> be the string consisting of all but the
              first four characters of <var>message</var>.</p>
            </li>

            <li>
              <p>Pass the <var>sdp</var> to the <a href=
              "#peerconnection-ice-agent"><code>PeerConnection</code> SDP
              Agent</a> as a subsequent offer or answer, to be interpreted as
              appropriate given the current state of the SDP Agent.
              [[!ICE]]</p>
            </li><!--
        <li>
          <p>The <a href="#ice-started-flag">ICE started flag</a> is false. Start the
          <a href="#peerconnection-ice-agent"><code>PeerConnection</code> ICE Agent</a>
          and pass it <var>sdp</var> as the initial offer from the other peer;
          the ICE Agent will then (asynchronously) construct the initial answer and
          transmit it as described above.</p>

          <p>If there is a <a href=
          "#remotely-initiated-data-udp-media-stream">remotely-initiated data UDP media
          stream</a> in the initial offer, and it has an encryption key advertised in its
          media description that is 16 bytes long, then that is the <a href=
          "#peerconnection-data-udp-media-stream"><code>PeerConnection</code> data UDP
          media stream</a>.</p>

          <p>After the initial answer has been sent, the ICE Agent MUST add all the
          streams in <code><a href=
          "#widl-PeerConnection-localStreams">localStreams</a></code> to the session, as
          described above. [[!ICE]]</p>
        </li>

        <li>
          <p>Let <var>connection</var>’s <a href="#ice-started-flag">ICE started
          flag</a> be true.</p>
        </li>

        <li>
          <p>Queue a task that sets <var>connection</var>’s
          <a href="#peerconnection-readiness-state"><code>PeerConnection</code> readiness
          state</a> to <code><a href=
          "#widl-PeerConnection-NEGOTIATING">NEGOTIATING</a></code> (1) and then
          <span title="fire a simple event">fires a simple event</span> named
          <code><a href=
          "#event-mediastream-connecting">connecting</a></code> at the <code><a>PeerConnection</a></code> object.</p>
        </li>
        -->
          </ol>

          <p>When a <a href=
          "#peerconnection-ice-agent"><code>PeerConnection</code> ICE Agent</a>
          forms a connection to the the far side and enters the state
          ICE_CONNECTED, the user agent MUST queue a task that sets the
          <code><a>PeerConnection</a></code> object’s <a href=
          "#peerconnection-readiness-state"><code>PeerConnection</code>
          readiness state</a> to <code><a href=
          "#widl-PeerConnection-ACTIVE">ACTIVE</a></code> (2) and then
          <span title="fire a simple event">fires a simple event</span> named
          <code title='event-MediaStream-open'><a href=
          "#event-mediastream-open">open</a></code> at the
          <code><a>PeerConnection</a></code> object.</p><!--
      <p>When a <a href="#peerconnection-ice-agent"><code>PeerConnection</code> ICE
      Agent</a> restarts ICE processing for any reason (e.g. because a peer is adding or
      removing a stream), the user agent MUST queue a task that sets the
      <code><a href="#peerconnection">PeerConnection</a></code> object’s <a href=
      "#peerconnection-readiness-state"><code>PeerConnection</code> readiness state</a>
      to <code><a href=
      "#widl-PeerConnection-NEGOTIATING">NEGOTIATING</a></code> (1) and then <span title=
      "fire a simple event">fires a simple event</span> named <code title=
      'event-MediaStream-connecting'><a href=
      "#event-mediastream-connecting">connecting</a></code> at the <code><a>PeerConnection</a></code> object.</p>
      -->
        </dd>

        <dt>const unsigned short NEW = 0</dt>

        <dd>The object was just created and its ICE and SDP Agent have not yet
        been started.</dd>

        <dt>const unsigned short NEGOTIATING = 1</dt>

        <dd>The peerConenction object is attempting to get to the point wehre
        media can flow.</dd>

        <dt>const unsigned short ACTIVE = 2</dt>

        <dd>A connection has been formed and if any media streams were
        successfully negotiated, any relevant media can be streaming.</dd>

        <dt>const unsigned short CLOSING = 4</dt>

        <dd>The object is starting to shut down after the <code><a href=
        "#dom-peerconnection-close">close()</a></code> method has been
        invoked.</dd>

        <dt>const unsigned short CLOSED = 3</dt>

        <dd>The <code><a href="#dom-peerconnection-close">close()</a></code>
        method has been invoked.</dd>

        <dt>readonly attribute unsigned short readyState</dt>

        <dd>
          <p>The <dfn id='dom-peerconnection-readystate'><code title=
          "">readyState</code></dfn> attribute MUST return the
          <code><a>PeerConnection</a></code> object’s <a href=
          "#peerconnection-readiness-state"><code>PeerConnection</code>
          readiness state</a>, represented by a number from the following
          list:</p>

          <dl>
            <dt><code><a>PeerConnection</a></code> . <code title=
            'widl-PeerConnection-NEW'><a href=
            "#widl-PeerConnection-NEW">NEW</a></code> (0)</dt>

            <dd>The object was just created, and no networking has yet
            occurred.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-NEGOTIATING'><a href=
            "#widl-PeerConnection-NEGOTIATING">NEGOTIATING</a></code> (1)</dt>

            <dd>The user agent is attempting to establish an connection with
            the ICE Agent and to negotiate codecs with the SDP Agent.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-ACTIVE'><a href=
            "#widl-PeerConnection-ACTIVE">ACTIVE</a></code> (2)</dt>

            <dd>The ICE Agent has found a connection the SDP Agent has
            performed a round of codec negotiation. It is possible for whatever
            media was negotiated to flow.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-CLOSING'><a href=
            "#widl-PeerConnection-CLOSED">CLOSING</a></code> (4)</dt>

            <dd>The <code><a>PeerConnection</a></code> object is terminating
            all media and is in the process of closing the Ice Agent and SDP
            Agent.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-CLOSED'><a href=
            "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3)</dt>

            <dd>The connection is closed.</dd>
          </dl>
        </dd>

        <dt>const unsigned short ICE_GATHERING = 0x100</dt>

        <dd>The ICE Agent is gather addresses that can be used.</dd>

        <dt>const unsigned short ICE_WAITING = 0x200</dt>

        <dd>THE ICE Agent has complete gathering addresses and is waiting for
        candidates to start checking.</dd>

        <dt>const unsigned short ICE_CHECKING = 0x300</dt>

        <dd>The ICE Agent is checking candidates but has not yet found a
        connection that works.</dd>

        <dt>const unsigned short ICE_CONNECTED = 0x400</dt>

        <dd>The ICE Agent has found at least one candidate that works but is
        still checking.</dd>

        <dt>const unsigned short ICE_COMPLETED = 0x500</dt>

        <dd>The ICE Agent has finished checking all candidates and a connection
        has been formed.</dd>

        <dt>const unsigned short ICE_FAILED = 0x600</dt>

        <dd>The ICE Agent has finished checking all candidates and no
        connection was worked.</dd>

        <dt>const unsigned short ICE_CLOSED = 0x700</dt>

        <dd>The ICE Agent is terminating and will no longer repined to STUN
        connectivity checks.</dd>

        <dt>readonly attribute unsigned short iceState</dt>

        <dd>
          <p>The <dfn id=
          'dom-peerconnection-icestate'><code>iceState</code></dfn> attribute
          MUST return the state of the <a href=
          "#peerconnection-ice-agent"><code>PeerConnection</code> ICE Agent</a>
          ICE state, represented by a number from the following list:</p>

          <dl>
            <dt><code><a>PeerConnection</a></code> . <code title=
            'widl-PeerConnection-NEW'><a href=
            "#widl-PeerConnection-NEW">NEW</a></code> (0)</dt>

            <dd>The object was just created, and no networking has yet
            occurred.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-GATHERING'><a href=
            "#widl-PeerConnection-ICE_GATHERING">ICE_GATHERING</a></code>
            (0x100)</dt>

            <dd>The ICE Agent is attempting to establish a gather
            addresses.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-ICE_WAITING'><a href=
            "#widl-PeerConnection-ICE_WAITING">ICE_WAITING</a></code>
            (0x200)</dt>

            <dd>The ICE Agent is waiting for candidates from the other side
            before it can start checking.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-CHECKING'><a href=
            "#widl-PeerConnection-ACTIVE">ICE_CHECKING</a></code> (0x300)</dt>

            <dd>The ICE Agent is checking candidates but has not yet found a
            connection.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-CONNECTED'><a href=
            "#widl-PeerConnection-CLOSED">ICE_CONNECTED</a></code> (0x400)</dt>

            <dd>The ICE Agent has found a connection but is still checking
            other candidates to see if there is a better connection.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-COMPLETED'><a href=
            "#widl-PeerConnection-CLOSED">ICE_COMPLETED</a></code> (0x500)</dt>

            <dd>The ICE Agent has finished checking and found a
            connection.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-ICE_FAILED'><a href=
            "#widl-PeerConnection-CLOSED">ICE_FAILED</a></code> (0x600)</dt>

            <dd>The ICE Agent is finished checking all candidates and failed to
            find a connection.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-CLOSED'><a href=
            "#widl-PeerConnection-CLOSED">ICE_CLOSED</a></code> (0x700)</dt>

            <dd>The ICE Agent has shut down and is no longer responding to STUN
            requests.</dd>
          </dl>
        </dd>

        <dt>const unsigned short SDP_IDLE = 0x1000</dt>

        <dd>A valid offer anser pair has been exchanged and the SDP Agent is
        waiting for the next SDP transaction.</dd>

        <dt>const unsigned short SDP_WAITING = 0x2000</dt>

        <dd>The SDP Agent has sent an SDP offer and is waiting for a
        response.</dd>

        <dt>const unsigned short SDP_GLARE = 0x3000</dt>

        <dd>Both side sent SDP offers at the same time and the SDP Agent is
        waiting to be able to retransmit the SDP offer.</dd>

        <dt>readonly attribute unsigned short sdpState</dt>

        <dd>
          <p>The <dfn id=
          'dom-peerconnection-sdpstate'><code>sdpState</code></dfn> attribute
          MUST return the state of the <code><a href=
          "#peerconnection">PeerConnection</a></code> SDP Agent , represented
          by a number from the following list:</p>

          <dl>
            <dt><code><a>PeerConnection</a></code> . <code title=
            'widl-PeerConnection-NEW'><a href=
            "#widl-PeerConnection-NEW">NEW</a></code> (0)</dt>

            <dd>The object was just created, and no networking has yet
            occurred.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-SDP_IDLE'><a href=
            "#widl-PeerConnection-SDP_IDLE">SDP_IDLE</a></code> (0x1000)</dt>

            <dd>At least one SDP offer or answer has been exchange and the SDP
            Agent is ready to send an SDP offer or receive an SDP answer.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-SDP_WAITING'><a href=
            "#widl-PeerConnection-SDP_WAITING">SDP_WAITING</a></code>
            (0x2000)</dt>

            <dd>The SDP Agent has sent and offer and is waiting for a
            answer.</dd>

            <dt><code><a>PeerConnection</a></code> . <code title=
            'dom-PeerConnection-SDP_GLARE'><a href=
            "#widl-PeerConnection-SDP_GLARE">SDP_GLARE</a></code> (0x3000)</dt>

            <dd>The SDP Agent received an offer while waiting for an answer and
            now much wait a random amount of time before retrying to send the
            offer.</dd>
          </dl>
        </dd>

        <dt>DataChannel createDataChannel([TreatNullAs=EmptyString] DOMString?
        label, optional DataChannelInit? dataChannelDict)</dt>

        <dd>
          <p>Creates a new <code><a>DataChannel</a></code> object with the
          given label. The <code><a>DataChannelInit</a></code> dictionary can
          be used to configure properties of underlying channel such as 
          <!--priority and--> data reliability. A corresponding
          <code><a>DataChannel</a></code> object is dispatched at the other
          peer if the channel setup was successful.</p>

          <p>When the <dfn id=
          'dom-peerconnection-createdatachannel'><code>createDataChannel()</code></dfn>
          method is invoked, the user agent MUST run the following steps.</p>

          <ol>
            <li>
              <p>If the <code><a>PeerConnection</a></code> object’s <a href=
              "#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> is <code><a href=
              "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), throw an
              <code>INVALID_STATE_ERR</code> exception.</p>
            </li>

            <li>
              <p>Let <var>channel</var> be a newly created
              <code><a>DataChannel</a></code> object.</p>
            </li>

            <li>
              <p>Initialize <var>channel</var>’s <code><a href=
              "#dom-datachannel-label">label</a></code> attribute to the value
              of the first argument.</p>
            </li>

            <li>
              <p>Initialize <var>channel</var>’s <code><a href=
              "#dom-datachannel-reliable">reliable</a></code> attribute to
              true.</p>
            </li>

            <li>
              <p>If the second argument is present and it contains a
              <code><a href=
              "#widl-DataChannelInit-reliable">reliable</a></code> dictionary
              member, then set <var>channel</var>’s <code><a href=
              "#dom-datachannel-reliable">reliable</a></code> attribute to the
              dictionary member value.</p>
            </li>

            <li>
              <p>Return <var>channel</var> and continue these steps in the
              background.</p>
            </li>

            <li>
              <p>Create <var>channel</var>’s associated <a>underlying data
              transport</a>.</p>
            </li>
          </ol>
        </dd>

        <dt>attribute Function? ondatachannel</dt>

        <dd>This event handler, of type <code><a href=
        "#event-peerconnection-datachannel">datachannel</a></code>, MUST be
        supported by all objects implementing the
        <code><a>PeerConnection</a></code> interface.</dd><!--
    <dt>void send (DOMString text)</dt>

    <dd>
      <p>Attempts to send the given text to the remote peer. This uses UDP, which is
      inherently unreliable; there is no guarantee that every message will be
      received.</p>

      <p>When a message sent in this manner from the other peer is received, a
      <code><a href=
      "#event-mediastream-message">message</a></code> event is fired at the
      <code><a>PeerConnection</a></code> object.</p>

      <p>The maximum length of <var>text</var> is 504 bytes after encoding the
      string as UTF-8; attempting to send a payload greater than 504 bytes results in an
      <code>INVALID_ACCESS_ERR</code> exception.</p>

      <p>When the <dfn id='dom-peerconnection-send'><code>send()</code></dfn> method is invoked, the
      user agent MUST run the following steps:</p>

      <ol>

        <li>
          <p>Let <var>message</var> be the method’s first argument.</p>
        </li>

        <li>
          <p>If the <code><a>PeerConnection</a></code> object’s
          <a href="#peerconnection-readiness-state"><code>PeerConnection</code> readiness
          state</a> is <code><a href=
          "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), throw an
          <code>INVALID_STATE_ERR</code> exception.</p>
        </li>

        <li>
          <p>Let <var>data</var> be <var>message</var> encoded as
          UTF-8. [[!UTF-8]]</p>
        </li>

        <li>
          <p>If <var>data</var> is longer than 504 bytes, throw an
          <code>INVALID_ACCESS_ERR</code> exception and abort these steps.</p>
        </li>
       <li>
          <p>If the <code><a>PeerConnection</a></code>’s <a href=
          "#peerconnection-data-udp-media-stream"><code>PeerConnection</code> data UDP
          media stream</a> is not an <a href="#active-data-udp-media-stream">active data
          UDP media stream</a>, abort these steps. No message is sent.</p>
        </li>

        <li>
          <p>If the user agent is rate-limiting packets sent using this API, and sending
          the data packet at this time would exceed the limit, then abort these steps.
          User agents MAY report this to the user, e.g. in a development console.</p>
        </li>

        <li>
          <p><a href="#transmit-a-data-packet-to-a-peer">Transmit a data packet to a
          peer</a> using the <code><a>PeerConnection</a></code>’s
          <a href="#peerconnection-data-udp-media-stream"><code>PeerConnection</code>
          data UDP media stream</a> with <var>data</var> as the message.</p>
        </li>
      </ol>
    </dd>
-->

        <dt>void addStream (MediaStream stream, MediaStreamHints hints)</dt>

        <dd>
          <p>Attempts to starting sending the given stream to the remote peer.
          The format for the MediaStreamHints objects is currently undefined by
          the specification.</p>

          <p>When the other peer starts sending a stream in this manner, an
          <code title='event-MediaStream-addstream'><a href=
          "#event-mediastream-addstream">addstream</a></code> event is fired at
          the <code><a>PeerConnection</a></code> object.</p><!-- </ol> -->

          <p>When the <dfn id='dom-peerconnection-addstream'><code title=
          "">addStream()</code></dfn> method is invoked, the user agent MUST
          run the following steps:</p>

          <ol>
            <li>
              <p>Let <var>stream</var> be the method’s first argument.</p>
            </li>

            <li>
              <p>Let <var>hints</var> be the method’s second argument.</p>
            </li>

            <li>
              <p>If the <code><a>PeerConnection</a></code> object’s <a href=
              "#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> is <code><a href=
              "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), throw an
              <code>INVALID_STATE_ERR</code> exception.</p>
            </li>

            <li>
              <p>If <var>stream</var> is already in the
              <code><a>PeerConnection</a></code> object’s <code title=
              'dom-PeerConnection-localStreams'><a href=
              "#widl-PeerConnection-localStreams">localStreams</a></code>
              object, then abort these steps.</p>
            </li>

            <li>
              <p>Add <var>stream</var> to the end of the
              <code><a>PeerConnection</a></code> object’s <code title=
              'dom-PeerConnection-localStreams'><a href=
              "#widl-PeerConnection-localStreams">localStreams</a></code>
              object.</p>
            </li>

            <li>
              <p>Return from the method.</p>
            </li>

            <li>
              <p>Parse the <var>hints</var> provided by the application and
              apply them to the MediaStream, if possible.</p>
            </li>

            <li>
              <p>Have the <code><a>PeerConnection</a></code> add a media stream
              for <var>stream</var> the next time the user agent <span title=
              "provide a stable state">provides a stable state</span>. Any
              other pending stream additions and removals MUST be processed at
              the same time.</p>
            </li>
          </ol>
        </dd>

        <dt>void removeStream (MediaStream stream)</dt>

        <dd>
          <p>Stops sending the given stream to the remote peer.</p>

          <p>When the other peer stops sending a stream in this manner, a
          <code title='event-MediaStream-removestream'><a href=
          "#event-mediastream-removestream">removestream</a></code> event is
          fired at the <code><a>PeerConnection</a></code> object.</p>

          <p>When the <dfn id='dom-peerconnection-removestream'><code title=
          "">removeStream()</code></dfn> method is invoked, the user agent MUST
          run the following steps:</p>

          <ol>
            <li>
              <p>Let <var>stream</var> be the method’s argument.</p>
            </li>

            <li>
              <p>If the <code><a>PeerConnection</a></code> object’s <a href=
              "#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> is <code><a href=
              "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), throw an
              <code>INVALID_STATE_ERR</code> exception.</p>
            </li>

            <li>
              <p>If <var>stream</var> is not in the
              <code><a>PeerConnection</a></code> object’s <code title=
              'dom-PeerConnection-localStreams'><a href=
              "#widl-PeerConnection-localStreams">localStreams</a></code>
              object, then abort these steps.</p>
            </li>

            <li>
              <p>Remove <var>stream</var> from the
              <code><a>PeerConnection</a></code> object’s <code title=
              'dom-PeerConnection-localStreams'><a href=
              "#widl-PeerConnection-localStreams">localStreams</a></code>
              object.</p>
            </li>

            <li>
              <p>Return from the method.</p>
            </li>

            <li>
              <p>Have the <code><a>PeerConnection</a></code>remove the media
              stream for <var>stream</var> the next time the user agent
              <span title="provide a stable state">provides a stable
              state</span>. Any other pending stream additions and removals
              MUST be processed at the same time.</p>
            </li><!-- section 9.1.1.2 -->
          </ol>
        </dd>

        <dt>readonly attribute MediaStream[] localStreams</dt>

        <dd>
          <p>Returns a live array containing the streams that the user agent is
          currently attempting to transmit to the remote peer (those that were
          added with <code title='dom-PeerConnection-addStream'><a href=
          "#dom-peerconnection-addstream">addStream()</a></code>).</p>

          <p>Specifically, it MUST return the read-only
          <code><a>MediaStream</a></code> array that the attribute was set to
          when the <code><a>PeerConnection</a></code>’s constructor ran.</p>
        </dd>

        <dt>readonly attribute MediaStream[] remoteStreams</dt>

        <dd>
          <p>Returns a live array containing the streams that the user agent is
          currently receiving from the remote peer.</p>

          <p>Specifically, it MUST return the read-only
          <code><a>MediaStream</a></code> array that the attribute was set to
          when the <code><a>PeerConnection</a></code>’s constructor ran.</p>

          <p>This array is updated when <code><a href=
          "#event-mediastream-addstream">addstream</a></code> and <code title=
          'event-MediaStream-removestream'><a href=
          "#event-mediastream-removestream">removestream</a></code> events are
          fired.</p>
        </dd>

        <dt>void close ()</dt>

        <dd>
          <p>When the <dfn id='dom-peerconnection-close'><code title=
          "">close()</code></dfn> method is invoked, the user agent MUST run
          the following steps:</p>

          <ol>
            <li>
              <p>If the <code><a>PeerConnection</a></code> object’s <a href=
              "#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> is <code><a href=
              "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), throw an
              <code>INVALID_STATE_ERR</code> exception.</p>
            </li>

            <li>
              <p>Destroy the <a href=
              "#peerconnection-ice-agent"><code>PeerConnection</code> ICE
              Agent</a>, abruptly ending any active ICE processing and any
              active streaming, and releasing any relevant resources (e.g. TURN
              permissions).</p>
            </li>

            <li>
              <p>Set the object’s <a href=
              "#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> to <code><a href=
              "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3).</p>
            </li><!--
   <li><p>Queue a task to fire a simple
   event named <code title="event-MediaStream-close">close</code> at the
   <code>PeerConnection</code> object.</p></p></li>
-->
          </ol>

          <p class='note'>The <code><a href=
          "#widl-PeerConnection-localStreams">localStreams</a></code> and
          <code title='dom-PeerConnection-remoteStreams'><a href=
          "#widl-PeerConnection-remoteStreams">remoteStreams</a></code> objects
          remain in the state they were in when the object was closed.</p>
        </dd>

        <dt>attribute Function? onconnecting</dt>

        <dd>This event handler, of <span title="event handler event type">event
        handler event type</span> <code><a href=
        "#event-mediastream-connecting">connecting</a></code>, MUST be
        supported by all objects implementing the
        <code><a>PeerConnection</a></code> interface.</dd>

        <dt>attribute Function? onopen</dt>

        <dd>This event handler, of <span title="event handler event type">event
        handler event type</span> <code><a href=
        "#event-mediastream-open">open</a></code>, MUST be supported by all
        objects implementing the <code><a>PeerConnection</a></code>
        interface.</dd>

        <dt>attribute Function? onstatechange</dt>

        <dd>This event handler, of <span title="event handler event type">event
        handler event type</span> <code><a href=
        "#event-mediastream-open">open</a></code>, MUST be supported by all
        objects implementing the <code><a>PeerConnection</a></code> interface.
        It is called any time the readyState, iceState, or sdpState
        changes.</dd><!--
    <dt>attribute Function? onmessage</dt>

    <dd>This event handler, of <span title="event handler event type">event handler event
    type</span> <code><a href=
    "#event-mediastream-message">message</a></code>, MUST be supported by all objects
    implementing the <code><a href="#peerconnection">PeerConnection</a></code>
    interface.</dd>
    -->

        <dt>attribute Function? onaddstream</dt>

        <dd>This event handler, of <span title="event handler event type">event
        handler event type</span> <code><a href=
        "#event-mediastream-addstream">addstream</a></code>, MUST be supported
        by all objects implementing the <code><a>PeerConnection</a></code>
        interface.</dd>

        <dt>attribute Function? onremovestream</dt>

        <dd>This event handler, of <span title="event handler event type">event
        handler event type</span> <code><a href=
        "#event-mediastream-removestream">removestream</a></code>, MUST be
        supported by all objects implementing the
        <code><a>PeerConnection</a></code> interface.</dd>
      </dl>

      <div title='PeerConnection implements EventTarget' class='idl'></div>
    </section>

    <section>
      <h3>SignalingCallback</h3>

      <dl title='[Callback, NoInterfaceObject] interface SignalingCallback'
      class='idl'>
        <dt>void handleEvent (DOMString message, PeerConnection source)</dt>

        <dd>Def TBD</dd>
      </dl>
    </section>

    <section>
      <h3>Examples</h3>

      <div>
        <p>When two peers decide they are going to set up a connection to each
        other, they both go through these steps. The STUN/TURN server
        configuration describes a server they can use to get things like their
        public IP address or to set up NAT traversal. They also have to send
        data for the signaling channel to each other using the same out-of-band
        mechanism they used to establish that they were going to communicate in
        the first place.</p>
        <pre class='example sh_javascript'>
// the first argument describes the STUN/TURN server configuration
var local = new PeerConnection('TURNS example.net', sendSignalingChannel);
local.signalingChannel(...); // if we have a message from the other side, pass it along here

// (aLocalStream is some LocalMediaStream object)
local.addStream(aLocalStream); // start sending video

function sendSignalingChannel(message) {
  ... // send message to the other side via the signaling channel
}

function receiveSignalingChannel (message) {
  // call this whenever we get a message on the signaling channel
  local.signalingChannel(message);
}

local.onaddstream = function (event) {
  // (videoElement is some &lt;video&gt; element)
  videoElement.src = URL.createObjectURL(event.stream);
};
</pre>
      </div>
    </section>
  </section>

  <section>
    <h2>Peer-to-peer Data API</h2>

    <p>The Peer-to-peer Data API lets a web application send and receive
    generic application data peer-to-peer.</p>

    <div class="note" title="hello">
      <p>Open issues (this should not be considered as a complete list of open
      issues)</p>

      <ul>
        <li>Data channel setup signaling (signaling via SDP and application
        specific signaling channel or first channel via SDP and consecutive
        channels via internal signalling).</li>

        <li>What can be shared with the WebSocket API specification regarding
        actual interfaces.</li>
      </ul>
    </div>

    <section>
      <h3>DataChannel</h3>

      <p>The <code><a>DataChannel</a></code> interface represents a
      bi-directional data channel between two peers. A
      <code><a>DataChannel</a></code> is created via a factory method on a
      <code><a>PeerConnection</a></code> object. The corresponding
      <code><a>DataChannel</a></code> object is then dispatched at the other
      peer if the channel setup was successful.</p>

      <p>Each <code><a>DataChannel</a></code> has an associated <dfn>underlying
      data transport</dfn> that is used to transport actual data to the other
      peer. The transport properties of the <a>underlying data transport</a>,
      such as reliability mode, is configured by the peer taking the initiative
      to create the channel. The receiving peer cannot change any transport
      properties of a offered data channel. The actual wire protocol between
      the peers is out of the scope for this specification.</p>

      <p>A <code><a>DataChannel</a></code> created with <code><a href=
      "#dom-peerconnection-createdatachannel">createDataChannel()</a></code>
      MUST initially be in the <code><a href=
      "#widl-DataChannel-CONNECTING">CONNECTING</a></code> (0) state. If the
      <code><a>DataChannel</a></code> object’s <a>underlying data transport</a>
      is successfully set up, the user agent MUST <a href=
      "#announce-datachannel-open">announce the <code>DataChannel</code> as
      open</a>.</p>

      <p>When the user agent is to <dfn id="announce-datachannel-open">announce
      a <code>DataChannel</code> as open</dfn>, the user agent MUST queue a
      task to run the following steps:</p>

      <ol>
        <li>
          <p>If the associated <code><a>PeerConnection</a></code> object’s
          <a href="#peerconnection-readiness-state"><code>PeerConnection</code>
          readiness state</a> is <code><a href=
          "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), abort these
          steps.</p>
        </li>

        <li>
          <p>Let <var>channel</var> be the <code><a>DataChannel</a></code>
          object to be announced.</p>
        </li>

        <li>
          <p>Set <var>channel</var>’s <code><a href=
          "#dom-datachannel-readystate">readyState</a></code> attribute to
          <code><a href="#widl-DataChannel-OPEN">OPEN</a></code> (1).</p>
        </li>

        <li>
          <p><a>Fire a simple event</a> named <code><a href=
          "#event-datachannel-open">open</a></code> at <var>channel</var>.</p>
        </li>
      </ol>

      <p>When an <a>underlying data transport</a> has been established, the
      user agent, of the peer that did not initiate the creation process MUST
      queue a task to run the following steps:</p>

      <ol>
        <li>
          <p>If the associated <code><a>PeerConnection</a></code> object’s
          <a href="#peerconnection-readiness-state"><code>PeerConnection</code>
          readiness state</a> is <code><a href=
          "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), abort these
          steps.</p>
        </li>

        <li>
          <p>Let <var>configuration</var> be an information bundle with
          key-value pairs, received from the other peer as a part of the
          process to establish the <a>underlying data channel</a>.</p>
        </li>

        <li>
          <p>Let <var>channel</var> be a newly created
          <code><a>DataChannel</a></code> object.</p>
        </li>

        <li>
          <p>Initialize <var>channel</var>’s <code><a href=
          "#dom-datachannel-label">label</a></code> attribute to value that
          corresponds to the "<code>label</code>" key in
          <var>configuration</var>.</p>
        </li>

        <li>
          <p>Initialize <var>channel</var>’s <code><a href=
          "#dom-datachannel-reliable">reliable</a></code> attribute to
          true.</p>
        </li>

        <li>
          <p>If <var>configuration</var> contains a key named
          "<code>reliable</code>", set <var>channel</var>’s <code><a href=
          "#dom-datachannel-reliable">reliable</a></code> attribute to the
          corresponding value.</p>
        </li><!--li>
      <p>Have the user agent <a href="#announce-datachannel-open">announce
      <var>connection</var> as open</a>.</p>
    </li-->

        <li>
          <p>Set <var>channel</var>’s <code><a href=
          "#dom-datachannel-readystate">readyState</a></code> attribute to
          <code><a href="#widl-DataChannel-OPEN">OPEN</a></code> (1).</p>
        </li>

        <li>
          <p><a>Fire a datachannel event</a> named <code><a href=
          "#event-peerconnection-datachannel">datachannel</a></code> with
          <var>channel</var> at the <code><a>PeerConnection</a></code>
          object.</p>
        </li>
      </ol>

      <p>When the <dfn id="tear-down-data-transport">process of tearing down a
      <code><a>DataChannel</a></code> object’s <a>underlying data
      transport</a></dfn> is initiated, the user agent MUST run the following
      steps:</p>

      <ol>
        <li>
          <p>If the associated <code><a>PeerConnection</a></code> object’s
          <a href="#peerconnection-readiness-state"><code>PeerConnection</code>
          readiness state</a> is <code><a href=
          "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), abort these
          steps.</p>
        </li>

        <li>
          <p>Let <var>channel</var> be the <code><a>DataChannel</a></code>
          object which is about to be closed.</p>
        </li>

        <li>
          <p>If <var>channel</var>’s <code><a href=
          "#dom-datachannel-readystate">readyState</a></code> is <code><a href=
          "#widl-DataChannel-CLOSED">CLOSING</a></code> (2) or <code><a href=
          "#widl-DataChannel-CLOSED">CLOSED</a></code> (3), then abort these
          steps.</p>
        </li>

        <li>
          <p>Set <var>channel</var>’s <code><a href=
          "#dom-datachannel-readystate">readyState</a></code> attribute to
          <code><a href="#widl-DataChannel-CLOSING">CLOSING</a></code> (2).</p>
        </li>

        <li>
          <p>Queue a task to run the following steps:</p>
        </li>

        <li>
          <ol>
            <li>
              <p>Close <var>channel</var>’s <a>underlying data
              transport</a>.</p>

              <div class="note">
                The data transport protocol will specify what happens to, e.g.
                buffered data, when the data transport is closed.
              </div>
            </li>

            <li>
              <p>Set <var>channel</var>’s <code><a href=
              "#dom-datachannel-readystate">readyState</a></code> attribute to
              <code><a href="#widl-DataChannel-CLOSED">CLOSED</a></code>
              (3).</p>
            </li>

            <li>
              <p>Fire a simple event named <code title=
              'event-DataChannel-close'><a href=
              "#event-datachannel-close">close</a></code> at
              <var>channel</var>.</p>
            </li>
          </ol>
        </li>
      </ol>

      <dl title='interface DataChannel' class='idl'>
        <dt>readonly attribute DOMString label</dt>

        <dd>
          <p>The <dfn id=
          'dom-datachannel-label'><code>DataChannel.label</code></dfn>
          attribute represents a label that can be used to distinguish this
          <code><a>DataChannel</a></code> object from other
          <code><a>DataChannel</a></code> objects. The attribute MUST return
          the value to which it was set when the
          <code><a>DataChannel</a></code> object was created.</p>
        </dd>

        <dt>readonly attribute boolean reliable</dt>

        <dd>
          <p>The <dfn id=
          'dom-datachannel-reliable'><code>DataChannel.reliable</code></dfn>
          attribute returns true if the <code><a>DataChannel</a></code> is
          reliable, and false otherwise. The attribute MUST return the value to
          which it was set when the <code><a>DataChannel</a></code> was
          created.</p>
        </dd><!--dt>readonly attribute long priority</dt>

    <dd>
      <p>The <dfn id='dom-datachannel-priority'><code>DataChannel.priority</code></dfn>
      attribute returns the priority of the <code><a>DataChannel</a></code>; a channel
      with a higher value is prioritized over a channel with a lower value. The attribute
      MUST return the value to which it was set when the the <code><a>DataChannel</a></code>
      was created.</p>

      <p>The value might not be the value given in the <code><a>DataChannelInit</a></code>
      dictionary since it may have been clamped to fit in the range of valid values.</p>
    </dd-->
        <!-- AbstractMessenger -->
        <!-- ready state -->

        <dt>const unsigned short CONNECTING = 0</dt>

        <dd>
          <p>The user agent is attempting to establish the <a>underlying data
          transport</a>. This is the initial state of a
          <code><a>DataChannel</a></code> object created with <code><a href=
          "#dom-peerconnection-createdatachannel">createDataChannel()</a></code>.</p>
        </dd>

        <dt>const unsigned short OPEN = 1</dt>

        <dd>
          <p>The <a>underlying data transport</a> is established and
          communication is possible. This is the initial state of a
          <code><a>DataChannel</a></code> object dispatched as a part of a
          <code><a>DataChannelEvent</a></code>.</p>
        </dd>

        <dt>const unsigned short CLOSING = 2</dt>

        <dd>
          <p>The process of closing down the <a>underlying data transport</a>
          has started.</p>
        </dd>

        <dt>const unsigned short CLOSED = 3</dt>

        <dd>
          <p>The <a>underlying data transport</a> has been closed or could not
          be established.</p>
        </dd>

        <dt>readonly attribute unsigned short readyState</dt>

        <dd>
          <p>The <dfn id=
          'dom-datachannel-readystate'><code>DataChannel.readyState</code></dfn>
          attribute represents the state of the <code>DataChannel</code>
          object. It MUST return the value to which the user agent last set it
          (as defined by the processing model algorithms). The attribute can
          have the following values: <dfn>CONNECTING</dfn>, <dfn>OPEN</dfn>,
          <dfn>CLOSING</dfn> or <dfn>CLOSED</dfn>.</p>
        </dd>

        <dt>readonly attribute unsigned long bufferedAmount</dt>

        <dd>
          <p class="note">FIXME: align behavior with WebSocket API</p>
        </dd><!-- networking -->

        <dt>[TreatNonCallableAsNull] attribute Function? onopen</dt>

        <dd>This event handler, of type <code><a href=
        "#event-datachannel-open">open</a></code>, MUST be supported by all
        objects implementing the <code><a>DataChannel</a></code>
        interface.</dd>

        <dt>[TreatNonCallableAsNull] attribute Function? onerror</dt>

        <dd>This event handler, of type <code><a href=
        "#event-datachannel-error">error</a></code>, MUST be supported by all
        objects implementing the <code><a>DataChannel</a></code>
        interface.</dd>

        <dt>[TreatNonCallableAsNull] attribute Function? onclose</dt>

        <dd>This event handler, of type <code><a href=
        "#event-datachannel-close">close</a></code>, MUST be supported by all
        objects implementing the <code><a>DataChannel</a></code>
        interface.</dd><!--dt>void close([Clamp] optional unsigned short code, optional DOMString reason)</dt>

    <dd>
      <p>Add text...</p>
    </dd-->

        <dt>void close()</dt>

        <dd>
          <p>Closes the <code><a>DataChannel</a></code>. It may be called
          regardless if the <code><a>DataChannel</a></code> object was created
          by this peer or the remote peer.</p>

          <p>When the <dfn><code>close()</code></dfn> method is called, the
          user agent MUST initiate <a href="#tear-down-data-transport">the
          process of tearing down</a> the <code>DataChannel</code> object’s
          <a>underlying data transport</a>.</p>
        </dd><!-- messaging -->

        <dt>[TreatNonCallableAsNull] attribute Function? onmessage</dt>

        <dd>This event handler, of type <code><a href=
        "#event-datachannel-message">message</a></code>, MUST be supported by
        all objects implementing the <code><a>DataChannel</a></code>
        interface.</dd>

        <dt>attribute DOMString binaryType</dt>

        <dd>
          <p class="note">FIXME: align behavior with WebSocket API</p>
        </dd>

        <dt>void send(DOMString data)</dt>

        <dd>
          <p class="note">FIXME: align behavior with WebSocket API</p>
        </dd>

        <dt>void send(ArrayBuffer data)</dt>

        <dd>
          <p class="note">FIXME: align behavior with WebSocket API</p>
        </dd>

        <dt>void send(Blob data)</dt>

        <dd>
          <p class="note">FIXME: align behavior with WebSocket API</p>
        </dd>
      </dl>

      <dl title='dictionary DataChannelInit' class='idl'>
        <dt>boolean reliable</dt>

        <dd>-</dd><!--dt>[Clamp] long priority</dt>

    <dd>-</dd-->
      </dl>
    </section>

    <section>
      <h3>Examples</h3>

      <div>
        <p>This simple example shows how to create a DataChannel, register an
        event listener to handle incoming data, and how to send a message.</p>
        <pre class='example sh_javascript'>
var chan = peerConn.createDataChannel("mylabel");

chan.onmessage = function (evt) {
    // use evt.data
};

chan.send("hello");
    
</pre>
      </div>

      <div>
        <p>This simple example shows how to register an event listener to
        handle the case when a remote peer creates a new DataChannel.</p>
        <pre class='example sh_javascript'>
peerConn.ondatachannel = function (evt) {
    var chan = evt.channel;

    chan.onmessage = function (evt) {
        // use evt.data
    };

    chan.onclose = function () {
        // remote side closed the data channel
    };
};
    
</pre>
      </div><!--div>
    <p>This simple example shows how configure two DataChannel objects for different purposes.</p>
    <pre  class='example sh_javascript'>
// the chat channel is reliable and not as prioritized as game data
var chatChan = peerConn.createDataChannel("chat", { "priority": 1 });

// the game data channel is prioritized and unreliable low latency channel for high performance
var gameDataChan = peerConn.createDataChannel("data", { "reliable": false, "priority": 10 });
    </pre>
  </div-->
    </section>
  </section>

  <section>
    <h2>Garbage collection</h2>

    <p>A <code>Window</code> object <dfn id='concept-peerconnection-owner'>has
    a strong reference</dfn> to any <code><a>PeerConnection</a></code> objects
    created from the constructor whose global object is that
    <code>Window</code> object.</p><!-- we
  could be less strict here, e.g. dropping the reference when there’s
  no way for an event to be fired because there’s no event handlers
  registered and there’s no way for the remote peer to notice anything
  because no media is streaming; or e.g. dropping the reference when
  the object reaches the CLOSED state. But as dropping the reference
  in those cases is black-box indistinguishable from keeping the
  reference, I haven't bothered to work out the exact rules. If you do
  change this, see the /unloading document cleanup steps/. -->
  </section>

  <section>
    <h2>Event definitions</h2>

    <section>
      <h3>MediaStreamTrackEvent</h3>

      <p>The <code><a href=
      "#event-mediastreamtracklist-addtrack">addtrack</a></code> and
      <code title='event-MediaStreamTracklist-removetrack'><a href=
      "#event-mediastreamtracklist-removetrack">removetrack</a></code> events
      use the <code><a>MediaStreamTrackEvent</a></code> interface.</p>

      <p><dfn title="Fire a track event">Firing a track event named
      <var>e</var></dfn> with a <code><a>MediaStreamTrack</a></code>
      <var>track</var> means that an event with the name <var>e</var>, which
      does not bubble (except where otherwise stated) and is not cancelable
      (except where otherwise stated), and which uses the
      <code><a>MediaStreamTrackEvent</a></code> interface with the
      <code><a href="#dom-mediastreamtrackevent-track">track</a></code>
      attribute set to <var>track</var>, MUST be created and dispatched at the
      given target.</p>

      <dl title=
      '[Constructor(DOMString type, optional MediaStreamTrackEventInit eventInitDict)] interface MediaStreamTrackEvent : Event'
      class='idl' data-merge='MediaStreamTrackEventInit'>
        <dt>readonly attribute MediaStreamTrack? track</dt>

        <dd>
          <p>The <dfn id=
          'dom-mediastreamtrackevent-track'><code>track</code></dfn> attribute
          represents the <code><a>MediaStreamTrack</a></code> object associated
          with the event.</p>
        </dd>
      </dl>

      <dl title='dictionary MediaStreamTrackEventInit : EventInit' class='idl'>
        <dt>MediaStreamTrack? track</dt>

        <dd>
          <p>-</p>
        </dd>
      </dl>
    </section>

    <section>
      <h3>MediaStreamEvent</h3>

      <p>The <code><a href="#event-mediastream-addstream">addstream</a></code>
      and <code title='event-MediaStream-removestream'><a href=
      "#event-mediastream-removestream">removestream</a></code> events use the
      <code><a>MediaStreamEvent</a></code> interface.</p>

      <p><dfn id='fire-a-stream-event' title="fire a stream event">Firing a
      stream event named <var>e</var></dfn> with a
      <code><a>MediaStream</a></code> <var>stream</var> means that an event
      with the name <var>e</var>, which does not bubble (except where otherwise
      stated) and is not cancelable (except where otherwise stated), and which
      uses the <code><a>MediaStreamEvent</a></code> interface with the
      <code><a href="#dom-mediastreamevent-stream">stream</a></code> attribute
      set to <var title="">stream</var>, MUST be created and dispatched at the
      given target.</p>

      <dl title=
      '[Constructor(DOMString type, optional MediaStreamEventInit eventInitDict)] interface MediaStreamEvent : Event'
      class='idl' data-merge='MediaStreamEventInit'>
        <dt>readonly attribute MediaStream? stream</dt>

        <dd>
          <p>The <dfn id=
          'dom-mediastreamevent-stream'><code>stream</code></dfn> attribute
          represents the <code><a>MediaStream</a></code> object associated with
          the event.</p>
        </dd>
      </dl>

      <dl title='dictionary MediaStreamEventInit : EventInit' class='idl'>
        <dt>MediaStream? stream</dt>

        <dd>
          <p>-</p>
        </dd>
      </dl>
    </section>

    <section>
      <h3>DataChannelEvent</h3>

      <p>The <code><a href=
      "#event-peerconnection-datachannel">datachannel</a></code> event use the
      <code><a>DataChannelEvent</a></code> interface.</p>

      <p><dfn id='fire-a-datachannel-event' title=
      "fire a datachannel event">Firing a datachannel event named
      <var>e</var></dfn> with a <code><a>DataChannel</a></code>
      <var>channel</var> means that an event with the name <var>e</var>, which
      does not bubble (except where otherwise stated) and is not cancelable
      (except where otherwise stated), and which uses the
      <code><a>DataChannelEvent</a></code> interface with the <code><a href=
      "#dom-datachannelevent-channel">channel</a></code> attribute set to
      <var>channel</var>, MUST be created and dispatched at the given
      target.</p>

      <dl title=
      '[Constructor(DOMString type, optional DataChannelEventInit eventInitDict)] interface DataChannelEvent : Event'
      class='idl' data-merge='DataChannelEventInit'>
        <dt>readonly attribute DataChannel? channel</dt>

        <dd>
          <p>The <dfn id=
          'dom-datachannelevent-channel'><code>channel</code></dfn> attribute
          represents the <code><a>DataChannel</a></code> object associated with
          the event.</p>
        </dd>
      </dl>

      <dl title='dictionary DataChannelEventInit : EventInit' class='idl'>
        <dt>DataChannel? channel</dt>

        <dd>-</dd>
      </dl>
    </section>
  </section>

  <section class="informative">
    <h2>Event summary</h2>

    <p>The following event fires on <code><a>MediaStream</a></code>
    objects:</p>

    <table>
      <tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      <tbody>
        <tr>
          <td><dfn id='event-mediastream-ended'><code>ended</code></dfn></td>

          <td><code>Event</code></td>

          <td>
            The <code><a>MediaStream</a></code> <a>finished</a> as a result of
            all tracks in the <code><a>MediaStream</a></code> <a title=
            "ended">ending</a>.
          </td>
        </tr>
      </tbody>
    </table>

    <p>The following event fires on <code><a>MediaStreamTrack</a></code>
    objects:</p>

    <table>
      <tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      <tbody>
        <tr>
          <td><dfn id=
          'event-mediastreamtrack-muted'><code>muted</code></dfn></td>

          <td><code>Event</code></td>

          <td>The <code><a>MediaStreamTrack</a></code> object’s source is
          temporarily unable to provide data.</td>
        </tr>

        <tr>
          <td><dfn id=
          'event-mediastreamtrack-unmuted'><code>unmuted</code></dfn></td>

          <td><code>Event</code></td>

          <td>The <code><a>MediaStreamTrack</a></code> object’s source is live
          again after having been temporarily unable to provide data.</td>
        </tr>

        <tr>
          <td><dfn id=
          'event-mediastreamtrack-ended'><code>ended</code></dfn></td>

          <td><code>Event</code></td>

          <td>The <code><a>MediaStreamTrack</a></code> object’s source will no
          longer provide any data, either because the user revoked the
          permissions, or because the source device has been ejected, or
          because the remote peer stopped sending data, or because the
          <code><a href="#dom-mediastream-stop">stop()</a></code> method was
          invoked.</td>
        </tr>
      </tbody>
    </table>

    <p>The following event fires on <code><a>MediaStreamTrackList</a></code>
    objects:</p>

    <table>
      <tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      <tbody>
        <tr>
          <td><dfn id=
          'event-mediastreamtracklist-addtrack'><code>addtrack</code></dfn></td>

          <td><code><a>MediaStreamTrackEvent</a></code></td>

          <td>A new <code><a>MediaStreamTrack</a></code> has been added to this
          list.</td>
        </tr>

        <tr>
          <td><dfn id=
          'event-mediastreamtracklist-removetrack'><code>removetrack</code></dfn></td>

          <td><code><a>MediaStreamTrackEvent</a></code></td>

          <td>A <code><a>MediaStreamTrack</a></code> has been removed from this
          list.</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>PeerConnection</a></code>
    objects:</p>

    <table>
      <tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      <tbody>
        <tr>
          <td><dfn id=
          'event-mediastream-connecting'><code>connecting</code></dfn></td>

          <td><code>Event</code></td>

          <td>The ICE Agent has begun negotiating with the peer. This can
          happen multiple times during the lifetime of the
          <code><a>PeerConnection</a></code> object.</td>
        </tr>

        <tr>
          <td><dfn id='event-mediastream-open'><code>open</code></dfn></td>

          <td><code>Event</code></td>

          <td>The ICE Agent has finished negotiating with the peer.</td>
        </tr><!--
        <tr>
          <td><dfn title="event-MediaStream-error"><code>error</code></dfn></td>
          <td><code>Event</code></td>
          <td></td>
        </tr>
        <tr>
          <td><dfn title="event-MediaStream-close"><code>close</code></dfn></td>
          <td><code>Event</code></td>
          <td>The <code title="dom-PeerConnection-close">close()</code> method was
            called. </td>
          </tr>
          -->

        <tr>
          <!-- '_'-suffix avoids name collision with DataChannel interface (ReSpec bug?)-->

          <td><dfn id=
          'event-peerconnection-datachannel'><code>datachannel_</code></dfn></td>

          <td><code><a>DataChannelEvent</a></code></td>

          <td>The other peer successfully created a new
          <code><a>DataChannel</a></code> object.</td>
        </tr>

        <tr>
          <td><dfn id=
          'event-mediastream-addstream'><code>addstream</code></dfn></td>

          <td><code><a>MediaStreamEvent</a></code></td>

          <td>A new stream has been added to the <code title=
          'dom-PeerConnection-remoteStreams'><a href=
          "#widl-PeerConnection-remoteStreams">remoteStreams</a></code>
          array.</td>
        </tr>

        <tr>
          <td><dfn id=
          'event-mediastream-removestream'><code>removestream</code></dfn></td>

          <td><code><a>MediaStreamEvent</a></code></td>

          <td>A stream has been removed from the <code title=
          'dom-PeerConnection-remoteStreams'><a href=
          "#widl-PeerConnection-remoteStreams">remoteStreams</a></code>
          array.</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>DataChannel</a></code>
    objects:</p>

    <table>
      <tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      <tbody>
        <tr>
          <td><dfn id='event-datachannel-open'><code>open</code></dfn></td>

          <td><code>Event</code></td>

          <td>
            The <code><a>DataChannel</a></code> object’s <a>underlying data
            transport</a> has been established (or re-established).
          </td>
        </tr>

        <tr>
          <td><dfn id='event-datachannel-error'><code>error</code></dfn></td>

          <td><code>Event</code></td>

          <td>-</td>
        </tr>

        <tr>
          <td><dfn id='event-datachannel-close'><code>close</code></dfn></td>

          <td><code>Event</code></td>

          <td>
            The <code><a>DataChannel</a></code> object’s <a>underlying data
            transport</a> has was closed.
          </td>
        </tr>

        <tr>
          <td><dfn id=
          'event-datachannel-message'><code>message</code></dfn></td>

          <td><code>MessageEvent</code></td>

          <td>A message was successfully received.</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2 id="application_html-peer-connection-data">
    application/html-peer-connection-data</h2>

    <p>This registration is for community review and will be submitted to the
    IESG for review, approval, and registration with IANA.</p><!--
   To: ietf-types@iana.org
   Subject: Registration of media type application/html-peer-connection-data
  -->

    <dl>
      <dt>Type name:</dt>

      <dd>application</dd>

      <dt>Subtype name:</dt>

      <dd>html-peer-connection-data</dd>

      <dt>Required parameters:</dt>

      <dd>No REQUIRED parameters</dd>

      <dt>Optional parameters:</dt>

      <dd>No OPTIONAL parameters</dd>

      <dt>Encoding considerations:</dt>

      <dd>This MIME type defines a binary protocol format which uses UTF-8 for
      text encoding.</dd>

      <dt>Security considerations:</dt>

      <dd>
        <p>This format is used for encoding UDP packets transmitted by
        potentially hostile Web page content via a trusted user agent to a
        destination selected by a potentially hostile remote server. To prevent
        this mechanism from being abused for cross-protocol attacks, all the
        data in these packets is masked so as to appear to be random noise. The
        intent of this masking is to reduce the potential attack scenarios to
        those already possible previously.</p>

        <p>However, this feature still allows random data to be sent to
        destinations that might not normally have been able to receive them,
        such as to hosts within the victim’s intranet. If a service within such
        an intranet cannot handle receiving UDP packets containing random
        noise, it might be vulnerable to attack from this feature.</p>
      </dd>

      <dt>Interoperability considerations:</dt>

      <dd>Rules for processing both conforming and non-conforming content are
      defined in this specification.</dd>

      <dt>Published specification:</dt>

      <dd>This document is the relevant specification.</dd>

      <dt>Applications that use this media type:</dt>

      <dd>This type is only intended for use with SDP. [[!SDP]]</dd>

      <dt>Additional information:</dt>

      <dd>
        <dl>
          <dt>Magic number(s):</dt>

          <dd>No sequence of bytes can uniquely identify data in this format,
          as all data in this format is intentionally masked to avoid
          cross-protocol attacks.</dd>

          <dt>File extension(s):</dt>

          <dd>This format is not for use with files.</dd>

          <dt>Macintosh file type code(s):</dt>

          <dd>This format is not for use with files.</dd>
        </dl>
      </dd>

      <dt>Person &amp; email address to contact for further information:</dt>

      <dd>Daniel C. Burnett &lt;dburnett@voxeo.com&gt;</dd>

      <dt>Intended usage:</dt>

      <dd>Common</dd>

      <dt>Restrictions on usage:</dt>

      <dd>No restrictions apply.</dd>

      <dt>Author:</dt>

      <dd>Daniel C. Burnett &lt;dburnett@voxeo.com&gt;</dd>

      <dt>Change controller:</dt>

      <dd>W3C</dd>
    </dl>

    <p>Fragment identifiers cannot be used with <code><a href=
    "#application_html-peer-connection-data">application/html-peer-connection-data</a></code>
    as URLs cannot be used to identify streams that use this format.</p>
  </section>

  <section>
    <h2>Change Log</h2>

    <p>This section will be removed before publication.</p>

    <h3>To Do Items</h3>

    <p>Need a way to indicate the type of the SDP when passing SDP strings.</p>

    <h3>Changes since 21 April 2012</h3>
    <ol>
      <li>Moved MediaStream and related definitions to getUserMedia.</li>
    </ol>

    <h3>Changes since 12 January 2012</h3>

    <ol>
      <li>Clarified what relation of Stream, Track, and Channel.</li>
    </ol>

    <h3>Changes since 17 October 2011</h3>

    <ol>
      <li>Tweak the introduction text and add a reference to the IETF RTCWEB
      group.</li>

      <li>Changed the first argument to getUserMedia to be an object.</li>

      <li>Added a MediaStreamHints object as a second argument to
      PeerConnection.addStream.</li>

      <li>Added AudioMediaStreamTrack class and DTMF interface.</li>
    </ol>

    <h3>Changes since 23 August 2011</h3>

    <ol>
      <li>Separated the SDP and ICE Agent into separate agents and added
      explicit state attributes for each.</li>

      <li>Removed the send method from PeerConenction and associated callback
      function.</li>

      <li>Modified MediaStream() constructor to take a list of MediaStreamTrack
      objects instead of a MediaStream. Removed text about MediaStream parent
      and child relationship.</li>

      <li>Added abstract.</li>

      <li>Moved a few paragraphs from the MediaStreamTrack.label section to the
      MediaStream.label section (where they belong).</li>

      <li>Split MediaStream.tracks into MediaStream.audioTracks and
      MediaStream.videoTracks.</li>

      <li>Removed a sentence that implied that track access is limited to
      LocalMediaStream.</li>

      <li>Updated a few getUserMedia()-examples to use MediaStreamOptions.</li>

      <li>Replaced calls to URL.getObjectURL() with URL.createObjectURL() in
      example code.</li>

      <li>Fixed some broken getUserMedia() links.</li>

      <li>Introduced state handling on MediaStreamTrack (removed state handling
      from MediaStream).</li>

      <li>Reintroduced onended on MediaStream to simplify checking if all
      tracks are ended.</li>

      <li>Aligned the MediaStreamTrack ended event dispatching behavior with
      that of MediaStream.</li>

      <li>Updated the LocalMediaStream.stop() algorithm to implicitly use the
      end track algorithm.</li>

      <li>Replaced an occurrence the term finished track with ended track (to
      align with rest of spec).</li>

      <li>Moved (and extended) the explanation about track references and media
      sources from LocalMediaStream to MediaStreamTrack.</li>

      <li>Removed section "Obtaining local multimedia content".</li>

      <li>Updated getUserMedia() calls in examples (changes in Media Capture TF
      spec).</li>

      <li>Introduced MediaStreamTrackList interface with support for adding and
      removing tracks.</li>

      <li>Updated the algorithm that is run when PeerConnection receives a
      stream (create new stream when negotiated instead of when data
      arrives).</li>

      <li>Removed some left-overs from the old Data Stream API.</li>

      <li>Initial import of new Data API.</li>

      <li>Renamed "underlying data channel" to "underlying data transport".
      Fixed closing procedures. Fixed some typos.</li>
    </ol>
  </section>

  <section class="appendix">
    <h2>Acknowledgements</h2>

    <p>The editors wish to thank the Working Group chairs, Harald Alvestrand
    and Stefan Håkansson, for their support.</p>
  </section>
</body>
</html>
